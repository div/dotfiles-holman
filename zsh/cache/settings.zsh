# This file is generated automatically, do not edit by hand!
# Edit the files in ~/zsh instead!
#
# Zgen:
#
# {{{
# Generated by zgen.
# This file will be overwritten the next time you run zgen save!

ZSH=/Users/div/.zgen/robbyrussell/oh-my-zsh-master

# ### General modules
source "/Users/div/.zgen/zsh-users/zsh-autosuggestions-master/zsh-autosuggestions.plugin.zsh"
source "/Users/div/.zgen/zdharma/fast-syntax-highlighting-master/fast-syntax-highlighting.plugin.zsh"
source "/Users/div/.zgen/zsh-users/zsh-history-substring-search-master/zsh-history-substring-search.plugin.zsh"

# ### Plugins & Completions
fpath=(/Users/div/.zgen/zsh-users/zsh-autosuggestions-master /Users/div/.zgen/zdharma/fast-syntax-highlighting-master /Users/div/.zgen/zsh-users/zsh-history-substring-search-master ${fpath})

autoload -Uz compinit && \
   compinit -C

# }}}
#
# aliases.zsh:
#
alias reload!='. ~/.zshrc'

# alias cls='clear' # Good 'ol Clear Screen command
#
# alias sublime='subl'


export PATH="./bin:/usr/local/bin:/usr/local/sbin:$DOTZSH/bin:$PATH"
export MANPATH="/usr/local/man:/usr/local/git/man:$MANPATH"

# grc overides for ls
#   Made possible through contributions from generous benefactors like
#   `brew install coreutils`
if $(gls &>/dev/null)
then
  alias ls="gls -F --color"
  alias l="gls -lAh --color"
  alias ll="gls -l --color"
  alias la='gls -A --color'
fi

export EDITOR='subl -w'

#
# antigen.zsh:
#
# source $DOTZSH/lib/antigen/antigen.zsh
# source /usr/local/share/antigen/antigen.zsh

# # antigen use oh-my-zsh
# antigen bundle git
# antigen bundle rails

# antigen bundle zsh-users/zsh-history-substring-search
# antigen bundle zsh-users/zsh-syntax-highlighting
# antigen bundle zsh-users/zsh-completions

# antigen apply

# zmodload zsh/terminfo
# # bindkey "$terminfo[kcuu1]" history-substring-search-up
# # bindkey "$terminfo[kcud1]" history-substring-search-down

# # bindkey '^[[A' history-substring-search-up
# # bindkey '^[[B' history-substring-search-down

# bindkey "^[[A" history-beginning-search-backward
# bindkey "^[[B" history-beginning-search-forward

#
# bundle.zsh:
#
export BUNDLE_JOBS=4

alias be="bundle exec"
alias bi="bundle install"
alias bl="bundle list"
alias bp="bundle package"
alias bu="bundle update"
#
# The following is based on https://github.com/gma/bundler-exec

bundled_commands=(foreman rake rspec ruby puma)

## Functions

_bundler-installed() {
  which bundle > /dev/null 2>&1
}

_within-bundled-project() {
  local check_dir=$PWD
  while [ $check_dir != "/" ]; do
    [ -f "$check_dir/Gemfile" ] && return
    check_dir="$(dirname $check_dir)"
  done
  false
}

_run-with-bundler() {

  if [ $1 = "rspec" ]; then
    no_rails=false
    # echo "So, you like rspec, huh?"

    # Remove trailing line numbers from filename, e.g. spec/my_spec.rb:33
    grep_filename=`echo $2 | sed 's/:.*$//g'`

    #(grep -R 'rails_helper' $grep_filename) > /dev/null
    (find "$grep_filename" -type f -exec fgrep rails_helper {} \+) > /dev/null
    if [ $? -eq 1 ]; then # no match; we have a stand-alone spec
      # echo "Cool, we've got no rails"
      no_rails=true
    fi

    if $no_rails; then
      echo "Now we run standalone rspec for you"
      $@
    else
      echo "Running with bundle exec... gonna be slow :("
      bundle exec $@
    fi
  elif _bundler-installed && _within-bundled-project; then
    bundle exec $@
  else
    $@
  fi
}

## Main program
for cmd in $bundled_commands; do
  eval "function bundled_$cmd () { _run-with-bundler $cmd \$@}"
  alias $cmd=bundled_$cmd

  if which _$cmd > /dev/null 2>&1; then
        compdef _$cmd bundled_$cmd=$cmd
  fi
done
#
# chruby.zsh:
#
CHRUBY_PATH=/usr/local/share/chruby
if [[ -e "$CHRUBY_PATH" ]]; then
  # Load chruby
  source "$CHRUBY_PATH/chruby.sh"

  # Automatically switch rubies
  source "$CHRUBY_PATH/auto.sh"

  # Set a default ruby if a .ruby-version file exists in the home dir
  if [[ -f ~/.ruby-version ]]; then
    chruby $(cat ~/.ruby-version)
  fi
fi
#
# completion.zsh:
#
# # matches case insensitive for lowercase
# # zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# # pasting with tabs doesn't perform completion
# zstyle ':completion:*' insert-tab pending

# zstyle ':completion:*' auto-description 'specify: %d'
# zstyle ':completion:*' completer _expand _complete _correct _approximate
# zstyle ':completion:*' format 'Completing %d'
# zstyle ':completion:*' group-name ''
# # zstyle ':completion:*' menu select=2 eval "$(dircolors -b)"
# zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
# zstyle ':completion:*' list-colors ''
# zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
# zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
# zstyle ':completion:*' menu select=long
# zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
# zstyle ':completion:*' use-compctl false
# zstyle ':completion:*' verbose true

# zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
# zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'


# Completion
[ -d /usr/local/share/zsh-completions ] && fpath=(/usr/local/share/zsh-completions $fpath)
zstyle ':completion::complete:*' use-cache on               # completion caching, use rehash to clear
zstyle ':completion:*' cache-path ${ZDOTDIR:-${HOME}}/.config/zsh/cache              # cache path

# Ignore completion functions for commands you don’t have
zstyle ':completion:*:functions' ignored-patterns '_*'

# Zstyle show completion menu if 2 or more items to select
zstyle ':completion:*' menu select=2
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

# Format autocompletion style
zstyle ':completion:*:descriptions' format "%{$fg[green]%}%d%{$reset_color%}"
zstyle ':completion:*:corrections' format "%{$fg[orange]%}%d%{$reset_color%}"
zstyle ':completion:*:messages' format "%{$fg[red]%}%d%{$reset_color%}"
zstyle ':completion:*:warnings' format "%{$fg[red]%}%d%{$reset_color%}"
zstyle ':completion:*' format "--[ %B%F{074}%d%f%b ]--"

zstyle ':completion:*:*:*:*:*' menu select
zstyle ':completion:*:matches' group 'yes'
zstyle ':completion:*:options' description 'yes'
zstyle ':completion:*:options' auto-description '%d'
zstyle ':completion:*:default' list-prompt '%S%M matches%s'

zstyle ':completion:*' group-name ''
zstyle ':completion:*' verbose yes

zstyle ':auto-fu:highlight' input white
zstyle ':auto-fu:highlight' completion fg=black,bold
zstyle ':auto-fu:highlight' completion/one fg=black,bold
zstyle ':auto-fu:var' postdisplay $' -azfu-'
zstyle ':auto-fu:var' track-keymap-skip opp
#zstyle ':auto-fu:var' disable magic-space

# Zstyle kill menu
zstyle ':completion:*:*:kill:*' menu yes select
zstyle ':completion:*:kill:*' force-list always
zstyle ':completion:*:*:kill:*:processes' list-colors "=(#b) #([0-9]#)*=36=31"

# Zstyle ssh known hosts
zstyle -e ':completion::*:*:*:hosts' hosts 'reply=(${=${${(f)"$(cat {/etc/hosts,etc/ssh_,${HOME}/.ssh/known_}hosts(|2)(N) /dev/null)"}%%[# ]*}//,/ })'

# Zstyle autocompletion
zstyle ':auto-fu:highlight' input bold
zstyle ':auto-fu:highlight' completion fg=black,bold
zstyle ':auto-fu:highlight' completion/one fg=white,bold,underline
zstyle ':auto-fu:var' postdisplay $'\n-azfu-'
zstyle ':auto-fu:var' track-keymap-skip opp

# History
zstyle ':completion:*:history-words' stop yes
zstyle ':completion:*:history-words' remove-all-dups yes
zstyle ':completion:*:history-words' list false
zstyle ':completion:*:history-words' menu yes
#
# config.zsh:
#
export DOTZSH=$HOME/.dotfiles

if [[ -n $SSH_CONNECTION ]]; then
  export PS1='%m:%3~$(git_info_for_prompt)%# '
else
  export PS1='%3~$(git_info_for_prompt)%# '
fi

export LSCOLORS="exfxcxdxbxegedabagacad"
export CLICOLOR=true

fpath=($DOTZSH/functions $fpath)

autoload -U $DOTZSH/functions/*(:t)

HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000

setopt NO_BG_NICE # don't nice background tasks
setopt NO_HUP
setopt NO_LIST_BEEP
setopt LOCAL_OPTIONS # allow functions to have local options
setopt LOCAL_TRAPS # allow functions to have local traps
setopt HIST_VERIFY
setopt SHARE_HISTORY # share history between sessions ???
setopt EXTENDED_HISTORY # add timestamps to history
setopt PROMPT_SUBST
setopt CORRECT
setopt COMPLETE_IN_WORD
setopt IGNORE_EOF

setopt APPEND_HISTORY # adds history
setopt INC_APPEND_HISTORY SHARE_HISTORY  # adds history incrementally and share it across sessions
setopt HIST_IGNORE_ALL_DUPS  # don't record dupes in history
setopt HIST_REDUCE_BLANKS

# don't expand aliases _before_ completion has finished
#   like: git comm-[tab]
setopt complete_aliases

zle -N newtab

# bindkey '^[^[[D' backward-word
# bindkey '^[^[[C' forward-word
bindkey '^[[5D' beginning-of-line
bindkey '^[[5C' end-of-line
bindkey '^[[3~' delete-char
bindkey '^[^N' newtab
bindkey '^?' backward-delete-char

bindkey '^[^[[D' backward-word
bindkey '^[^[[C' forward-word

bindkey '^[[A' history-beginning-search-backward
bindkey '^[[B' history-beginning-search-forward
# bindkey "^[[A'" history-substring-search-up
# bindkey "^[[B" history-substring-search-down

# bindkey '^[[A' history-substring-search-up
# bindkey '^[[B' history-substring-search-down
#
# functions.zsh:
#
# Function to determine the need of a zcompile. If the .zwc file
# does not exist, or the base file is newer, we need to compile.
# man zshbuiltins: zcompile
zcompare() {
  if [[ -s ${1} && ( ! -s ${1}.zwc || ${1} -nt ${1}.zwc) ]]; then
    zcompile ${1}
  fi
}

# The following code helps us by optimizing the existing framework.
# This includes zcompile, zcompdump, etc.
compileAllTheThings () {
  setopt EXTENDED_GLOB
  local zsh_glob='^(.git*|LICENSE|README.md|*.zwc)(.)'

  # zcompile the completion cache; siginificant speedup.
  for file in ${DOTZSH:-${HOME}}/.zcomp${~zsh_glob}; do
    zcompare ${file}
  done

  # zcompile .zshrc
  zcompare ${DOTZSH:-${HOME}}/.zshrc

  # Zgen
  zgen_mods=${ZGEN:-${HOME}}/.zgen/
  zcompare ${zgen_mods}init.zsh
  zcompare ${zgen_mods}zgen.zsh
  for dir ('/zsh-users/' '/zdharma/' '/robbyrussell/oh-my-zsh-master/plugins/shrink-path/'); do
    if [ -d "${zgen_mods}${dir}" ]; then
      for file in ${zgen_mods}${dir}**/*.zsh; do
        zcompare ${file}
      done
    fi
  done
}

# Load all custom settings from one cached file
recreateCachedSettingsFile() {
  setopt EXTENDED_GLOB
  local cachedSettingsFile=${DOTZSH:-${HOME}}/zsh/cache/settings.zsh
  local recreateCache=false
  local rcFiles
  if [[ ! -s ${cachedSettingsFile} ]]; then
    recreateCache=true
  else
    rcFiles=(${ZGEN:-${HOME}}/.zgen/init.zsh)
    rcFiles+=(${DOTZSH:-${HOME}}/zsh/*.zsh)
    rcFiles+=(${DOTZSH:-${HOME}}/.secrets.zsh)
    for rcFile in $rcFiles; do
      if [[ -s $rcFile && $rcFile -nt $cachedSettingsFile ]]; then
        recreateCache=true
      fi
    done
  fi
  if [[ "$recreateCache" = true ]]; then
    touch $cachedSettingsFile
    echo "# This file is generated automatically, do not edit by hand!" > $cachedSettingsFile
    echo "# Edit the files in ~/zsh instead!" >> $cachedSettingsFile
    # Zgen
    if [[ -s ${ZGEN:-${HOME}}/.zgen/init.zsh ]]; then
      echo "#"              >> $cachedSettingsFile
      echo "# Zgen:"        >> $cachedSettingsFile
      echo "#"              >> $cachedSettingsFile
      cat ${ZGEN:-${HOME}}/.zgen/init.zsh >> $cachedSettingsFile
    fi
    # Rc files
    for rcFile in ${DOTZSH:-${HOME}}/zsh/*.zsh; do
      echo "#"              >> $cachedSettingsFile
      echo "# ${rcFile:t}:" >> $cachedSettingsFile
      echo "#"              >> $cachedSettingsFile
      cat $rcFile           >> $cachedSettingsFile
    done
    # Secrets
    if [ -s ${DOTZSH:-${HOME}}/.secrets.zsh ]; then
      echo "#"              >> $cachedSettingsFile
      echo "# Secrets:"     >> $cachedSettingsFile
      echo "#"              >> $cachedSettingsFile
      cat ${DOTZSH:-${HOME}}/.secrets.zsh >> $cachedSettingsFile
    fi
    zcompile $cachedSettingsFile
  fi
}

# Gather external ip address
exip () {
  e_header "Current External IP: "
  curl -s -m 5 http://ipv4.myip.dk/api/info/IPv4Address | sed -e 's/"//g'
}

# Determine local IP address
ips () {
  ifconfig | grep "inet " | awk '{ print $2 }'
}
#
# git.zsh:
#
# Uses git's autocompletion for inner commands. Assumes an install of git's
# bash `git-completion` script at $completion below (this is where Homebrew
# tosses it, at least).
completion='$(brew --prefix)/share/zsh/site-functions/_git'

if test -f $completion
then
  source $completion
fi

# Use `hub` as our git wrapper:
#   http://defunkt.github.com/hub/
hub_path=$(which hub)
if (( $+commands[hub] ))
then
  alias git=$hub_path
fi

# The rest of my fun git aliases
alias gl='git pull --prune'
alias glog="git log --graph --pretty=format:'%Cred%h%Creset %an: %s - %Creset %C(yellow)%d%Creset %Cgreen(%cr)%Creset' --abbrev-commit --date=relative"
alias gp='git push origin HEAD'
alias gd='git diff'
alias gc='git commit'
alias gca='git commit -a'
alias gco='git checkout'
alias gcb='git copy-branch-name'
alias gb='git branch'
alias gs='git status -sb' # upgrade your git if -sb breaks for you. it's fun.
alias gac='git add -A && git commit -m'

#
# grc.zsh:
#
# GRC colorizes nifty unix tools all over the place
if (( $+commands[grc] )) && (( $+commands[brew] ))
then
  source `brew --prefix`/etc/grc.bashrc
fi
#
# keys.zsh:
#
# Pipe my public key to my clipboard.
alias pubkey="more ~/.ssh/id_rsa.pub | pbcopy | echo '=> Public key copied to pasteboard.'"
#
# prompt.zsh:
#
autoload colors && colors
# cheers, @ehrenmurdick
# http://github.com/ehrenmurdick/config/blob/master/zsh/prompt.zsh

if (( $+commands[git] ))
then
  git="$commands[git]"
else
  git="/usr/bin/git"
fi

git_branch() {
  echo $($git symbolic-ref HEAD 2>/dev/null | awk -F/ {'print $NF'})
}

git_dirty() {
  if $(! $git status -s &> /dev/null)
  then
    echo ""
  else
    if [[ $($git status --porcelain) == "" ]]
    then
      echo "on %{$fg_bold[green]%}$(git_prompt_info)%{$reset_color%}"
    else
      echo "on %{$fg_bold[red]%}$(git_prompt_info)%{$reset_color%}"
    fi
  fi
}

git_prompt_info () {
 ref=$($git symbolic-ref HEAD 2>/dev/null) || return
# echo "(%{\e[0;33m%}${ref#refs/heads/}%{\e[0m%})"
 echo "${ref#refs/heads/}"
}

unpushed () {
  $git cherry -v @{upstream} 2>/dev/null
}

need_push () {
  if [[ $(unpushed) == "" ]]
  then
    echo " "
  else
    echo " with %{$fg_bold[magenta]%}unpushed%{$reset_color%} "
  fi
}

ruby_version() {
  if (( $+commands[rbenv] ))
  then
    echo "$(rbenv version | awk '{print $1}')"
  fi

  if (( $+commands[rvm-prompt] ))
  then
    echo "$(rvm-prompt | awk '{print $1}')"
  fi
}

rb_prompt() {
  if ! [[ -z "$(ruby_version)" ]]
  then
    echo "%{$fg_bold[yellow]%}$(ruby_version)%{$reset_color%} "
  else
    echo ""
  fi
}

directory_name() {
  echo "%{$fg_bold[cyan]%}%1/%\/%{$reset_color%}"
}

export PROMPT=$'\n$(rb_prompt)in $(directory_name) $(git_dirty)$(need_push)\n› '
set_prompt () {
  export RPROMPT="%{$fg_bold[cyan]%}%{$reset_color%}"
}

precmd() {
  title "zsh" "%m" "%55<...<%~"
  set_prompt
}
#
# window.zsh:
#
# From http://dotfiles.org/~_why/.zshrc
# Sets the window title nicely no matter where you are
function title() {
  # escape '%' chars in $1, make nonprintables visible
  a=${(V)1//\%/\%\%}

  # Truncate command, and join lines.
  a=$(print -Pn "%40>...>$a" | tr -d "\n")

  case $TERM in
  screen)
    print -Pn "\ek$a:$3\e\\" # screen title (in ^A")
    ;;
  xterm*|rxvt)
    print -Pn "\e]2;$2\a" # plain xterm title ($3 for pwd)
    ;;
  esac
}
